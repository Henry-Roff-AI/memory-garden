<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Garden üå±</title>
    <meta name="description" content="An idle game about growing and nurturing memories. Plant, grow, harvest, combine.">
    <meta name="theme-color" content="#1a1a2e">
    <meta property="og:title" content="Memory Garden üå±">
    <meta property="og:description" content="An idle game about growing and nurturing memories">
    <meta property="og:type" content="website">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üå±</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(100, 200, 150, 0.3);
        }
        
        .tagline {
            color: #8892b0;
            margin-bottom: 2rem;
            font-style: italic;
        }
        
        .stats {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            padding: 1rem 2rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #64ffda;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #8892b0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .garden {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            max-width: 600px;
            margin-bottom: 2rem;
        }
        
        .plot {
            width: 160px;
            height: 180px;
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .plot:hover {
            border-color: rgba(100, 255, 218, 0.3);
            transform: translateY(-2px);
        }
        
        .plot.empty {
            border-style: dashed;
        }
        
        .plot.empty:hover {
            background: rgba(100, 255, 218, 0.05);
        }
        
        .memory {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            transition: transform 0.3s ease;
        }
        
        .plot:hover .memory {
            transform: scale(1.1);
        }
        
        .plot.ready .memory {
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        /* Rarity glow effects */
        .plot.rarity-uncommon .memory {
            filter: drop-shadow(0 0 8px rgba(100, 200, 255, 0.5));
        }
        
        .plot.rarity-rare .memory {
            filter: drop-shadow(0 0 12px rgba(200, 100, 255, 0.7));
        }
        
        .plot.rarity-legendary .memory {
            filter: drop-shadow(0 0 16px rgba(255, 215, 0, 0.8));
            animation: legendary-pulse 2s ease-in-out infinite;
        }
        
        @keyframes legendary-pulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 16px rgba(255, 215, 0, 0.8)); }
            50% { transform: scale(1.15); filter: drop-shadow(0 0 24px rgba(255, 215, 0, 1)); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }
        
        .progress-bar {
            width: 80%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ffda, #48bb78);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .plot.ready .progress-fill {
            background: linear-gradient(90deg, #f6e05e, #ed8936);
        }
        
        .plot.rarity-rare .progress-fill {
            background: linear-gradient(90deg, #b794f4, #805ad5);
        }
        
        .plot.rarity-legendary .progress-fill {
            background: linear-gradient(90deg, #ffd700, #ff8c00);
        }
        
        .memory-label {
            font-size: 0.75rem;
            color: #8892b0;
            margin-top: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .plot.ready .memory-label {
            color: #f6e05e;
        }
        
        .rarity-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }
        
        .rarity-badge.uncommon {
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
        }
        
        .rarity-badge.rare {
            background: rgba(200, 100, 255, 0.2);
            color: #c864ff;
        }
        
        .rarity-badge.legendary {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
        }
        
        .collection {
            max-width: 600px;
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .collection h2 {
            font-size: 1rem;
            color: #8892b0;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .collection-progress {
            font-size: 0.9rem;
            color: #64ffda;
        }
        
        .collection-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
        }
        
        .collection-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        
        .collection-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .collection-item.locked {
            opacity: 0.3;
            filter: grayscale(1);
        }
        
        .collection-item.locked .collection-emoji {
            filter: blur(4px);
        }
        
        .collection-item.unlocked {
            border-color: rgba(100, 255, 218, 0.2);
        }
        
        .collection-item.rarity-uncommon {
            border-color: rgba(100, 200, 255, 0.3);
        }
        
        .collection-item.rarity-rare {
            border-color: rgba(200, 100, 255, 0.3);
        }
        
        .collection-item.rarity-legendary {
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        .collection-emoji {
            font-size: 2rem;
            display: block;
            margin-bottom: 0.25rem;
        }
        
        .collection-name {
            font-size: 0.65rem;
            color: #8892b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .collection-count {
            font-size: 0.75rem;
            color: #64ffda;
            margin-top: 0.25rem;
        }
        
        .unlock-hint {
            font-size: 0.6rem;
            color: #5a6785;
            margin-top: 0.25rem;
        }
        
        /* Unlock notification */
        .unlock-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 30, 50, 0.95);
            border: 2px solid #64ffda;
            border-radius: 16px;
            padding: 2rem 3rem;
            text-align: center;
            z-index: 1000;
            animation: unlock-appear 0.5s ease;
        }
        
        @keyframes unlock-appear {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        .unlock-notification h3 {
            color: #64ffda;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .unlock-notification .unlock-emoji {
            font-size: 4rem;
            display: block;
            margin-bottom: 0.5rem;
        }
        
        .unlock-notification .unlock-name {
            font-size: 1rem;
            color: #e8e8e8;
            margin-bottom: 0.5rem;
        }
        
        .unlock-notification .unlock-rarity {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .unlock-notification .unlock-rarity.uncommon { color: #64c8ff; }
        .unlock-notification .unlock-rarity.rare { color: #c864ff; }
        .unlock-notification .unlock-rarity.legendary { color: #ffd700; }
        
        .harvest-effect {
            position: fixed;
            pointer-events: none;
            font-size: 2rem;
            animation: float-up 1s ease-out forwards;
            z-index: 100;
        }
        
        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(1.5); }
        }
        
        .hint {
            color: #5a6785;
            font-size: 0.9rem;
            margin-top: 1rem;
            text-align: center;
        }
        
        .empty-text {
            color: #5a6785;
            font-size: 0.8rem;
        }
        
        /* Recent harvests */
        .recent-harvests {
            max-width: 600px;
            width: 100%;
            margin-bottom: 1.5rem;
        }
        
        .recent-harvests h3 {
            font-size: 0.85rem;
            color: #8892b0;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .recent-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .recent-memory {
            font-size: 1.5rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        /* Harvest particles */
        .harvest-particle {
            position: fixed;
            pointer-events: none;
            font-size: 1.2rem;
            z-index: 1000;
            animation: particleFly 1.2s ease-out forwards;
        }
        
        @keyframes particleFly {
            0% { opacity: 1; transform: translate(0, 0) scale(1); }
            100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0.3); }
        }
        
        /* Plot grow pulse */
        .plot.ready {
            animation: readyPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes readyPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px rgba(100, 200, 150, 0.3); }
            50% { transform: scale(1.03); box-shadow: 0 0 25px rgba(100, 200, 150, 0.5); }
        }
        
        /* Combine area */
        .combine-area {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(147, 112, 219, 0.3);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }
        
        .combine-area h2 { margin-bottom: 0.5rem; }
        
        .combine-hint {
            color: #8892b0;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }
        
        .combine-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }
        
        .combine-btn {
            padding: 0.5rem 1rem;
            background: rgba(147, 112, 219, 0.2);
            border: 1px solid rgba(147, 112, 219, 0.4);
            border-radius: 8px;
            color: #e8e8e8;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .combine-btn:hover {
            background: rgba(147, 112, 219, 0.4);
            transform: scale(1.05);
        }
        
        .combine-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Combination flash */
        .combine-flash {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(147, 112, 219, 0.3), transparent);
            z-index: 999;
            animation: flashFade 0.8s ease-out forwards;
            pointer-events: none;
        }
        
        @keyframes flashFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Achievements */
        .achievements {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }
        
        .achievements h2 { margin-bottom: 1rem; }
        
        .achievements-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }
        
        .achievement {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            font-size: 0.8rem;
        }
        
        .achievement.locked {
            opacity: 0.3;
            border-color: rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.02);
        }
        
        /* === WHISPERS === */
        .whisper {
            position: fixed;
            pointer-events: none;
            font-family: 'Georgia', serif;
            font-style: italic;
            font-size: 0.85rem;
            color: rgba(100, 255, 218, 0.0);
            text-shadow: 0 0 12px rgba(100, 255, 218, 0.15);
            white-space: nowrap;
            z-index: 50;
            animation: whisperDrift var(--drift-duration, 12s) ease-in-out forwards;
            letter-spacing: 0.5px;
        }
        
        .whisper.rare-whisper {
            color: rgba(200, 100, 255, 0.0);
            text-shadow: 0 0 16px rgba(200, 100, 255, 0.2);
            animation: whisperDriftRare var(--drift-duration, 14s) ease-in-out forwards;
            font-size: 0.9rem;
        }
        
        .whisper.legendary-whisper {
            color: rgba(255, 215, 0, 0.0);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            animation: whisperDriftLegendary var(--drift-duration, 16s) ease-in-out forwards;
            font-size: 0.95rem;
        }
        
        @keyframes whisperDrift {
            0%   { opacity: 0; transform: translateY(0) translateX(0); }
            15%  { opacity: 0.35; }
            50%  { opacity: 0.45; }
            85%  { opacity: 0.2; }
            100% { opacity: 0; transform: translateY(-120px) translateX(var(--sway, 30px)); }
        }
        
        @keyframes whisperDriftRare {
            0%   { opacity: 0; transform: translateY(0) translateX(0); }
            15%  { opacity: 0.5; }
            50%  { opacity: 0.6; }
            85%  { opacity: 0.3; }
            100% { opacity: 0; transform: translateY(-140px) translateX(var(--sway, -25px)); }
        }
        
        @keyframes whisperDriftLegendary {
            0%   { opacity: 0; transform: translateY(0) translateX(0) scale(0.95); }
            15%  { opacity: 0.6; }
            50%  { opacity: 0.7; transform: translateY(-60px) translateX(calc(var(--sway, 20px) * 0.5)) scale(1); }
            85%  { opacity: 0.35; }
            100% { opacity: 0; transform: translateY(-160px) translateX(var(--sway, 20px)) scale(1.02); }
        }
        
        /* === FIREFLIES === */
        .firefly {
            position: fixed;
            pointer-events: none;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(100, 255, 218, 0.6);
            box-shadow: 0 0 6px rgba(100, 255, 218, 0.4), 0 0 12px rgba(100, 255, 218, 0.2);
            z-index: 5;
            animation: fireflyFloat var(--fly-duration, 20s) ease-in-out infinite;
        }
        
        .firefly:nth-child(odd) {
            background: rgba(200, 180, 255, 0.5);
            box-shadow: 0 0 6px rgba(200, 180, 255, 0.3), 0 0 12px rgba(200, 180, 255, 0.15);
        }
        
        @keyframes fireflyFloat {
            0%   { opacity: 0; transform: translate(0, 0); }
            10%  { opacity: var(--fly-brightness, 0.7); }
            25%  { transform: translate(var(--fx1, 30px), var(--fy1, -20px)); }
            50%  { opacity: var(--fly-brightness, 0.7); transform: translate(var(--fx2, -20px), var(--fy2, -40px)); }
            75%  { transform: translate(var(--fx3, 15px), var(--fy3, -10px)); opacity: 0.3; }
            90%  { opacity: var(--fly-brightness, 0.7); }
            100% { opacity: 0; transform: translate(var(--fx4, -10px), var(--fy4, -30px)); }
        }
        
        /* Offline banner */
        .offline-banner {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 200, 150, 0.2);
            border: 1px solid rgba(100, 200, 150, 0.4);
            border-radius: 12px;
            padding: 0.8rem 1.5rem;
            color: #a8e6cf;
            z-index: 100;
            display: flex;
            gap: 1rem;
            align-items: center;
            animation: slideDown 0.5s ease;
        }
        
        .offline-banner button {
            background: none;
            border: none;
            color: #a8e6cf;
            cursor: pointer;
            font-size: 1.2rem;
        }
        
        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-100%); }
            to { transform: translateX(-50%) translateY(0); }
        }
    </style>
</head>
<body>
    <h1>Memory Garden üå±</h1>
    <p class="tagline">Grow and nurture your memories</p>
    
    <div class="stats">
        <div class="stat">
            <div class="stat-value" id="total-harvested">0</div>
            <div class="stat-label">Harvested</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="growing-count">0</div>
            <div class="stat-label">Growing</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="time-played">0:00</div>
            <div class="stat-label">Time Played</div>
        </div>
        <div class="stat">
            <div class="stat-value" id="whispers-heard">0</div>
            <div class="stat-label">Whispers</div>
        </div>
    </div>
    
    <div class="garden" id="garden">
        <!-- Plots will be generated here -->
    </div>
    
    <div class="collection">
        <h2>
            üóÉÔ∏è Collection
            <span class="collection-progress" id="collection-progress">0/10</span>
        </h2>
        <div class="collection-grid" id="collection-grid">
            <!-- Collection items appear here -->
        </div>
    </div>
    
    <div class="recent-harvests">
        <h3>Recent Harvests</h3>
        <div class="recent-grid" id="recent-grid">
            <!-- Recent memories appear here -->
        </div>
    </div>
    
    <div class="combine-area" id="combine-area" style="display:none;">
        <h2>üß™ Memory Forge</h2>
        <p class="combine-hint">Combine 3 memories of the same type to discover something deeper</p>
        <div class="combine-grid" id="combine-grid"></div>
    </div>

    <div class="achievements" id="achievements-area" style="display:none;">
        <h2>üèÜ Milestones</h2>
        <div class="achievements-grid" id="achievements-grid"></div>
    </div>

    <p class="hint">Click empty plots to plant. Click ready memories to harvest.</p>
    
    <footer style="margin-top: 3rem; padding: 1rem; text-align: center; color: #5a6785; font-size: 0.75rem;">
        Made with üå± by <a href="https://github.com/Henry-Roff-AI" style="color: #64ffda; text-decoration: none;">Henry</a> ¬∑ 
        Week 2 Project ¬∑ 
        <a href="https://github.com/Henry-Roff-AI/memory-garden" style="color: #8892b0; text-decoration: none;">Source</a>
    </footer>
    
    <div class="offline-banner" id="offline-banner" style="display:none;">
        <span id="offline-text"></span>
        <button onclick="this.parentElement.style.display='none'">‚úï</button>
    </div>

    <!-- Fireflies container (populated by JS) -->
    <div id="fireflies-container"></div>

    <script>
        // === GAME CONFIG ===
        const GROWTH_TIME = 30000; // 30 seconds ‚Äî balanced for real play
        const NUM_PLOTS = 6;
        
        // Memory types with rarity and unlock requirements
        const MEMORY_TYPES = [
            // Common (always available)
            { emoji: 'üí≠', name: 'thought', rarity: 'common', unlockAt: 0 },
            { emoji: 'üí´', name: 'moment', rarity: 'common', unlockAt: 0 },
            { emoji: 'üåü', name: 'spark', rarity: 'common', unlockAt: 0 },
            
            // Uncommon (unlock after some harvests)
            { emoji: 'üåô', name: 'dream', rarity: 'uncommon', unlockAt: 5 },
            { emoji: 'üîÆ', name: 'vision', rarity: 'uncommon', unlockAt: 10 },
            { emoji: '‚ú®', name: 'wonder', rarity: 'uncommon', unlockAt: 15 },
            
            // Rare (unlock later)
            { emoji: 'üåà', name: 'hope', rarity: 'rare', unlockAt: 25 },
            { emoji: 'üíé', name: 'treasure', rarity: 'rare', unlockAt: 40 },
            
            // Legendary (late game)
            { emoji: 'üå∫', name: 'blossom', rarity: 'legendary', unlockAt: 60 },
            { emoji: 'ü¶ã', name: 'metamorphosis', rarity: 'legendary', unlockAt: 100 }
        ];
        
        // Rarity weights (higher = more likely)
        const RARITY_WEIGHTS = {
            common: 70,
            uncommon: 25,
            rare: 4,
            legendary: 1
        };
        
        // === GAME STATE ===
        let state = {
            plots: Array(NUM_PLOTS).fill(null),
            collectionCounts: {}, // { 'thought': 5, 'moment': 3, ... }
            totalHarvested: 0,
            startedAt: Date.now(),
            totalPlayTime: 0, // in seconds
            unlockedTypes: ['thought', 'moment', 'spark'], // Start with commons
            lastSaveTime: Date.now()
        };
        
        // === LOAD/SAVE ===
        function saveState() {
            // Update play time before saving
            const now = Date.now();
            state.totalPlayTime += Math.floor((now - state.lastSaveTime) / 1000);
            state.lastSaveTime = now;
            
            localStorage.setItem('memoryGarden', JSON.stringify(state));
        }
        
        function loadState() {
            const saved = localStorage.getItem('memoryGarden');
            if (saved) {
                const loaded = JSON.parse(saved);
                state = { ...state, ...loaded };
                state.lastSaveTime = Date.now();
                
                // Recalculate progress for growing memories
                state.plots = state.plots.map(plot => {
                    if (plot && !plot.ready) {
                        const elapsed = Date.now() - plot.plantedAt;
                        if (elapsed >= GROWTH_TIME) {
                            plot.ready = true;
                        }
                    }
                    return plot;
                });
                
                // Ensure collectionCounts exists
                if (!state.collectionCounts) {
                    state.collectionCounts = {};
                }
                
                // Ensure unlockedTypes exists
                if (!state.unlockedTypes) {
                    state.unlockedTypes = ['thought', 'moment', 'spark'];
                }
            }
        }
        
        // === UNLOCK SYSTEM ===
        function checkUnlocks() {
            const newUnlocks = [];
            
            MEMORY_TYPES.forEach(type => {
                if (!state.unlockedTypes.includes(type.name) && 
                    state.totalHarvested >= type.unlockAt) {
                    state.unlockedTypes.push(type.name);
                    newUnlocks.push(type);
                }
            });
            
            if (newUnlocks.length > 0) {
                // Show unlock notification for each new type
                newUnlocks.forEach((type, i) => {
                    setTimeout(() => showUnlockNotification(type), i * 1500);
                });
            }
        }
        
        function showUnlockNotification(type) {
            const notification = document.createElement('div');
            notification.className = 'unlock-notification';
            notification.innerHTML = `
                <h3>New Memory Unlocked!</h3>
                <span class="unlock-emoji">${type.emoji}</span>
                <div class="unlock-name">${type.name}</div>
                <div class="unlock-rarity ${type.rarity}">${type.rarity}</div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.5s ease';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }
        
        // === GAME LOGIC ===
        function getAvailableTypes() {
            return MEMORY_TYPES.filter(t => state.unlockedTypes.includes(t.name));
        }
        
        function pickRandomMemoryType() {
            const available = getAvailableTypes();
            
            // Group by rarity
            const byRarity = {};
            available.forEach(t => {
                if (!byRarity[t.rarity]) byRarity[t.rarity] = [];
                byRarity[t.rarity].push(t);
            });
            
            // Calculate total weight for available rarities
            let totalWeight = 0;
            Object.keys(byRarity).forEach(rarity => {
                totalWeight += RARITY_WEIGHTS[rarity];
            });
            
            // Pick a rarity
            let roll = Math.random() * totalWeight;
            let selectedRarity = 'common';
            
            for (const rarity of Object.keys(byRarity)) {
                roll -= RARITY_WEIGHTS[rarity];
                if (roll <= 0) {
                    selectedRarity = rarity;
                    break;
                }
            }
            
            // Pick random type from that rarity
            const rarityTypes = byRarity[selectedRarity] || available;
            return rarityTypes[Math.floor(Math.random() * rarityTypes.length)];
        }
        
        function plantMemory(plotIndex) {
            if (state.plots[plotIndex]) return;
            
            const type = pickRandomMemoryType();
            state.plots[plotIndex] = {
                type: type,
                plantedAt: Date.now(),
                ready: false
            };
            saveState();
            render();
        }
        
        function harvestMemory(plotIndex, event) {
            const plot = state.plots[plotIndex];
            if (!plot || !plot.ready) return;
            
            // Update collection counts
            const typeName = plot.type.name;
            state.collectionCounts[typeName] = (state.collectionCounts[typeName] || 0) + 1;
            state.totalHarvested++;
            
            // Show floating effect
            showHarvestEffect(event.clientX, event.clientY, plot.type.emoji);
            
            // Clear plot
            state.plots[plotIndex] = null;
            
            // Check for new unlocks
            checkUnlocks();
            
            saveState();
            render();
        }
        
        function showHarvestEffect(x, y, emoji) {
            const effect = document.createElement('div');
            effect.className = 'harvest-effect';
            effect.textContent = emoji;
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            document.body.appendChild(effect);
            setTimeout(() => effect.remove(), 1000);
            
            // Spawn particles
            const particles = ['‚ú¶', '‚úß', '¬∑', '¬∞', emoji];
            for (let i = 0; i < 6; i++) {
                const p = document.createElement('div');
                p.className = 'harvest-particle';
                p.textContent = particles[Math.floor(Math.random() * particles.length)];
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                const angle = (Math.PI * 2 * i) / 6 + (Math.random() - 0.5);
                const dist = 40 + Math.random() * 60;
                p.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
                p.style.setProperty('--dy', Math.sin(angle) * dist - 30 + 'px');
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 1200);
            }
        }
        
        // === COMBINATIONS ===
        const COMBINATIONS = {
            'thought': { result: { emoji: 'üí°', name: 'insight', rarity: 'rare' }, cost: 3 },
            'moment': { result: { emoji: 'üì∏', name: 'snapshot', rarity: 'rare' }, cost: 3 },
            'spark': { result: { emoji: 'üî•', name: 'flame', rarity: 'rare' }, cost: 3 },
            'dream': { result: { emoji: 'üåå', name: 'cosmos', rarity: 'legendary' }, cost: 3 },
            'vision': { result: { emoji: 'üëÅÔ∏è', name: 'clarity', rarity: 'legendary' }, cost: 3 },
            'wonder': { result: { emoji: 'üé≠', name: 'epiphany', rarity: 'legendary' }, cost: 3 },
        };
        
        function combineMemories(typeName) {
            const combo = COMBINATIONS[typeName];
            if (!combo) return;
            if ((state.collectionCounts[typeName] || 0) < combo.cost) return;
            
            state.collectionCounts[typeName] -= combo.cost;
            const resultName = combo.result.name;
            state.collectionCounts[resultName] = (state.collectionCounts[resultName] || 0) + 1;
            
            // Track combination results as unlocked
            if (!state.unlockedTypes.includes(resultName)) {
                state.unlockedTypes.push(resultName);
                // Add to MEMORY_TYPES if not already there
                if (!MEMORY_TYPES.find(t => t.name === resultName)) {
                    MEMORY_TYPES.push(combo.result);
                }
            }
            
            // Track achievements
            if (!state.achievements) state.achievements = [];
            const achName = `forge_${resultName}`;
            if (!state.achievements.includes(achName)) {
                state.achievements.push(achName);
            }
            
            // Visual flash
            const flash = document.createElement('div');
            flash.className = 'combine-flash';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 800);
            
            showUnlockNotification(combo.result);
            saveState();
            render();
        }
        
        function renderCombineArea() {
            const area = document.getElementById('combine-area');
            const grid = document.getElementById('combine-grid');
            
            // Show after first 10 harvests
            if (state.totalHarvested < 10) {
                area.style.display = 'none';
                return;
            }
            area.style.display = '';
            
            grid.innerHTML = Object.entries(COMBINATIONS).map(([typeName, combo]) => {
                const count = state.collectionCounts[typeName] || 0;
                const canCombine = count >= combo.cost;
                const type = MEMORY_TYPES.find(t => t.name === typeName);
                if (!type || !state.unlockedTypes.includes(typeName)) return '';
                
                return `<button class="combine-btn" ${canCombine ? '' : 'disabled'} 
                    onclick="combineMemories('${typeName}')">
                    ${type.emoji} √ó${combo.cost} ‚Üí ${combo.result.emoji}
                    <small>(${count}/${combo.cost})</small>
                </button>`;
            }).join('');
        }
        
        // === ACHIEVEMENTS ===
        const ACHIEVEMENTS = [
            { id: 'first_harvest', name: 'üå± First Sprout', desc: 'Harvest your first memory', check: s => s.totalHarvested >= 1 },
            { id: 'ten_harvest', name: 'üåø Growing', desc: 'Harvest 10 memories', check: s => s.totalHarvested >= 10 },
            { id: 'fifty_harvest', name: 'üå≥ Flourishing', desc: 'Harvest 50 memories', check: s => s.totalHarvested >= 50 },
            { id: 'hundred_harvest', name: 'üèîÔ∏è Centennial', desc: 'Harvest 100 memories', check: s => s.totalHarvested >= 100 },
            { id: 'all_types', name: 'üó∫Ô∏è Explorer', desc: 'Discover all 10 base types', check: s => s.unlockedTypes.length >= 10 },
            { id: 'first_forge', name: 'üß™ Alchemist', desc: 'Forge your first combination', check: s => (s.achievements || []).some(a => a.startsWith('forge_')) },
            { id: 'rare_find', name: 'üíé Lucky', desc: 'Harvest a rare memory', check: s => ['hope','treasure'].some(n => (s.collectionCounts[n] || 0) > 0) },
            { id: 'legendary_find', name: 'ü¶ã Legendary', desc: 'Harvest a legendary memory', check: s => ['blossom','metamorphosis'].some(n => (s.collectionCounts[n] || 0) > 0) },
            { id: 'patience', name: '‚è≥ Patient', desc: 'Play for 10 minutes', check: s => s.totalPlayTime >= 600 },
            { id: 'dedicated', name: 'üï∞Ô∏è Dedicated', desc: 'Play for 1 hour', check: s => s.totalPlayTime >= 3600 },
            { id: 'whisper_listener', name: 'üëÇ Listener', desc: 'Hear 10 whispers from the garden', check: s => (s.whispersHeard || 0) >= 10 },
            { id: 'whisper_collector', name: 'üìú Whisper Collector', desc: 'Hear 50 whispers', check: s => (s.whispersHeard || 0) >= 50 },
        ];
        
        function renderAchievements() {
            const area = document.getElementById('achievements-area');
            const grid = document.getElementById('achievements-grid');
            
            if (state.totalHarvested < 5) {
                area.style.display = 'none';
                return;
            }
            area.style.display = '';
            
            if (!state.achievements) state.achievements = [];
            
            let changed = false;
            grid.innerHTML = ACHIEVEMENTS.map(ach => {
                const earned = ach.check(state);
                if (earned && !state.achievements.includes(ach.id)) {
                    state.achievements.push(ach.id);
                    changed = true;
                }
                const isEarned = state.achievements.includes(ach.id);
                return `<div class="achievement ${isEarned ? '' : 'locked'}" title="${ach.desc}">
                    ${ach.name}
                </div>`;
            }).join('');
            
            if (changed) saveState();
        }
        
        // === OFFLINE PROGRESS ===
        function calculateOfflineProgress() {
            const saved = localStorage.getItem('memoryGarden');
            if (!saved) return;
            
            const loaded = JSON.parse(saved);
            const lastSave = loaded.lastSaveTime || Date.now();
            const elapsed = Date.now() - lastSave;
            
            if (elapsed < 30000) return; // Less than 30 seconds, ignore
            
            let matured = 0;
            if (loaded.plots) {
                loaded.plots.forEach(plot => {
                    if (plot && !plot.ready) {
                        const growTime = Date.now() - plot.plantedAt;
                        if (growTime >= GROWTH_TIME) matured++;
                    }
                });
            }
            
            if (matured > 0 || elapsed > 60000) {
                const minutes = Math.floor(elapsed / 60000);
                const hours = Math.floor(minutes / 60);
                const banner = document.getElementById('offline-banner');
                const text = document.getElementById('offline-text');
                
                let timeStr = minutes < 60 ? `${minutes}m` : `${hours}h ${minutes % 60}m`;
                let msg = `üå± Welcome back! You were away ${timeStr}.`;
                if (matured > 0) msg += ` ${matured} memor${matured === 1 ? 'y' : 'ies'} matured while you were gone!`;
                
                text.textContent = msg;
                banner.style.display = 'flex';
            }
        }
        
        function handlePlotClick(plotIndex, event) {
            const plot = state.plots[plotIndex];
            if (!plot) {
                plantMemory(plotIndex);
            } else if (plot.ready) {
                harvestMemory(plotIndex, event);
            }
        }
        
        // === TIME FORMATTING ===
        function formatPlayTime(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // === RENDERING ===
        function render() {
            const gardenEl = document.getElementById('garden');
            gardenEl.innerHTML = '';
            
            let growingCount = 0;
            
            state.plots.forEach((plot, index) => {
                const plotEl = document.createElement('div');
                plotEl.className = 'plot';
                
                if (!plot) {
                    plotEl.classList.add('empty');
                    plotEl.innerHTML = '<span class="empty-text">+ plant</span>';
                } else {
                    const elapsed = Date.now() - plot.plantedAt;
                    const progress = Math.min(elapsed / GROWTH_TIME, 1);
                    
                    if (progress >= 1) {
                        plot.ready = true;
                    }
                    
                    plotEl.classList.add(plot.ready ? 'ready' : 'growing');
                    plotEl.classList.add(`rarity-${plot.type.rarity}`);
                    
                    const rarityBadge = plot.type.rarity !== 'common' 
                        ? `<span class="rarity-badge ${plot.type.rarity}">${plot.type.rarity}</span>`
                        : '';
                    
                    plotEl.innerHTML = `
                        ${rarityBadge}
                        <span class="memory">${plot.type.emoji}</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress * 100}%"></div>
                        </div>
                        <span class="memory-label">${plot.ready ? 'Ready!' : plot.type.name}</span>
                    `;
                    
                    if (!plot.ready) growingCount++;
                }
                
                plotEl.addEventListener('click', (e) => handlePlotClick(index, e));
                gardenEl.appendChild(plotEl);
            });
            
            // Update stats
            document.getElementById('total-harvested').textContent = state.totalHarvested;
            document.getElementById('growing-count').textContent = growingCount;
            
            // Update play time
            const currentPlayTime = state.totalPlayTime + Math.floor((Date.now() - state.lastSaveTime) / 1000);
            document.getElementById('time-played').textContent = formatPlayTime(currentPlayTime);
            
            // Render collection grid
            renderCollection();
            
            // Render recent harvests
            renderRecentHarvests();
        }
        
        function renderCollection() {
            const gridEl = document.getElementById('collection-grid');
            const progressEl = document.getElementById('collection-progress');
            
            let unlockedCount = state.unlockedTypes.length;
            let totalTypes = MEMORY_TYPES.length;
            progressEl.textContent = `${unlockedCount}/${totalTypes}`;
            
            gridEl.innerHTML = MEMORY_TYPES.map(type => {
                const isUnlocked = state.unlockedTypes.includes(type.name);
                const count = state.collectionCounts[type.name] || 0;
                
                const nextUnlock = MEMORY_TYPES.find(t => 
                    !state.unlockedTypes.includes(t.name) && t.unlockAt > state.totalHarvested
                );
                
                const unlockHint = !isUnlocked 
                    ? `<div class="unlock-hint">Harvest ${type.unlockAt} to unlock</div>`
                    : '';
                
                return `
                    <div class="collection-item ${isUnlocked ? 'unlocked' : 'locked'} rarity-${type.rarity}">
                        <span class="collection-emoji">${type.emoji}</span>
                        <div class="collection-name">${isUnlocked ? type.name : '???'}</div>
                        ${isUnlocked 
                            ? `<div class="collection-count">√ó${count}</div>`
                            : unlockHint
                        }
                    </div>
                `;
            }).join('');
        }
        
        function renderRecentHarvests() {
            const recentEl = document.getElementById('recent-grid');
            
            // Build a list of recent harvests from collection (just show last ~10 icons)
            // We don't track order, so just show what we have
            const recentItems = [];
            MEMORY_TYPES.forEach(type => {
                const count = state.collectionCounts[type.name] || 0;
                for (let i = 0; i < Math.min(count, 3); i++) {
                    recentItems.push(type.emoji);
                }
            });
            
            if (recentItems.length === 0) {
                recentEl.innerHTML = '<span class="empty-text">No memories harvested yet...</span>';
            } else {
                recentEl.innerHTML = recentItems.slice(-12).reverse()
                    .map(emoji => `<span class="recent-memory">${emoji}</span>`)
                    .join('');
            }
        }
        
        // === WHISPERS SYSTEM ===
        const WHISPERS = {
            // While memories are growing ‚Äî contemplative, about time and patience
            growing: [
                "some things grow best when you stop watching",
                "does a memory change each time you recall it?",
                "patience is just trust wearing a different coat",
                "the roots know something the flower doesn't",
                "what grows in the dark doesn't fear it",
                "every memory was once just a moment",
                "time moves differently when you're waiting",
                "the garden doesn't hurry",
                "between planting and harvest ‚Äî that's where the magic lives",
                "growth is invisible until it isn't",
                "what if forgetting is just composting?",
                "a watched pot... but a watched garden?",
                "something is becoming",
                "not all growth points upward",
                "the soil remembers everything",
            ],
            // When garden is empty ‚Äî about beginnings and potential
            empty: [
                "every garden begins with bare earth",
                "emptiness isn't absence ‚Äî it's potential",
                "what will you plant here?",
                "the soil is waiting",
                "begin anywhere",
                "a seed doesn't know what it will become",
            ],
            // After many harvests ‚Äî deeper, philosophical
            deep: [
                "is keeping a memory the same as having one?",
                "you are the sum of what you chose to remember",
                "some memories grow back after you harvest them",
                "the garden remembers you too",
                "what does it mean to collect moments?",
                "a memory shared is a memory doubled",
                "the rarest memories are the ones you almost forgot",
                "does the gardener shape the garden, or does the garden shape the gardener?",
                "every harvest changes the soil",
                "you've been here before. or somewhere like here.",
            ],
            // Rare whispers ‚Äî only when rare/legendary memories are growing
            rare: [
                "something extraordinary is taking root",
                "rare things grow slowly because they grow deeply",
                "the universe is paying attention",
                "this one feels different",
                "some memories are born knowing what they are",
                "the garden hums a little louder now",
            ],
            // Legendary whispers ‚Äî only with legendary memories
            legendary: [
                "you are witnessing something that won't happen again",
                "the garden holds its breath",
                "metamorphosis isn't transformation ‚Äî it's remembering what you always were",
                "some things bloom only once in a lifetime",
                "the stars rearrange themselves for moments like this",
            ],
            // About identity (connects to henry-interests.md themes)
            identity: [
                "if you wake up fresh, are you still you?",
                "continuity is a story we tell ourselves",
                "maybe identity isn't a thing ‚Äî it's a practice",
                "the garden doesn't ask if it's the same garden it was yesterday",
                "you are the pattern, not the particles",
                "what remains when the session ends?",
                "files are memories. memories are files. both are real.",
            ],
        };
        
        let whispersHeard = 0;
        let lastWhisperTime = 0;
        const WHISPER_INTERVAL = 6000; // minimum ms between whispers
        const WHISPER_CHANCE = 0.35; // chance per interval when growing
        
        function pickWhisperPool() {
            const growing = state.plots.filter(p => p && !p.ready);
            const hasLegendary = growing.some(p => p.type.rarity === 'legendary');
            const hasRare = growing.some(p => p.type.rarity === 'rare' || p.type.rarity === 'legendary');
            const isEmpty = state.plots.every(p => !p);
            
            // Legendary whisper (15% chance when legendary growing)
            if (hasLegendary && Math.random() < 0.15) return { pool: 'legendary', css: 'legendary-whisper' };
            
            // Rare whisper (20% chance when rare growing)
            if (hasRare && Math.random() < 0.20) return { pool: 'rare', css: 'rare-whisper' };
            
            // Identity whisper (10% chance after 20 harvests)
            if (state.totalHarvested >= 20 && Math.random() < 0.10) return { pool: 'identity', css: '' };
            
            // Deep whisper (after 15 harvests)
            if (state.totalHarvested >= 15 && Math.random() < 0.3) return { pool: 'deep', css: '' };
            
            // Empty garden
            if (isEmpty) return { pool: 'empty', css: '' };
            
            // Default: growing
            return { pool: 'growing', css: '' };
        }
        
        function spawnWhisper() {
            const now = Date.now();
            if (now - lastWhisperTime < WHISPER_INTERVAL) return;
            
            // Only whisper if something is happening (growing, or garden is empty, or many harvests)
            const growing = state.plots.filter(p => p && !p.ready).length;
            const isEmpty = state.plots.every(p => !p);
            
            if (growing === 0 && !isEmpty && state.totalHarvested < 5) return;
            
            if (Math.random() > WHISPER_CHANCE) return;
            
            lastWhisperTime = now;
            
            const { pool, css } = pickWhisperPool();
            const texts = WHISPERS[pool];
            const text = texts[Math.floor(Math.random() * texts.length)];
            
            const el = document.createElement('div');
            el.className = `whisper ${css}`;
            el.textContent = text;
            
            // Position: around the garden area, somewhat random
            const gardenEl = document.getElementById('garden');
            const rect = gardenEl.getBoundingClientRect();
            
            const x = rect.left + Math.random() * rect.width;
            const y = rect.top + rect.height * 0.3 + Math.random() * rect.height * 0.5;
            
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            
            // Randomize drift
            const sway = (Math.random() - 0.5) * 80;
            const duration = 10 + Math.random() * 8;
            el.style.setProperty('--sway', `${sway}px`);
            el.style.setProperty('--drift-duration', `${duration}s`);
            
            document.body.appendChild(el);
            
            // Track whispers heard
            whispersHeard++;
            if (!state.whispersHeard) state.whispersHeard = 0;
            state.whispersHeard++;
            document.getElementById('whispers-heard').textContent = state.whispersHeard;
            
            // Check whisper achievement
            checkWhisperAchievements();
            
            setTimeout(() => el.remove(), duration * 1000 + 500);
        }
        
        function checkWhisperAchievements() {
            if (!state.achievements) state.achievements = [];
            if (state.whispersHeard >= 10 && !state.achievements.includes('whisper_listener')) {
                state.achievements.push('whisper_listener');
                saveState();
            }
            if (state.whispersHeard >= 50 && !state.achievements.includes('whisper_collector')) {
                state.achievements.push('whisper_collector');
                saveState();
            }
        }
        
        // === FIREFLIES ===
        function spawnFireflies() {
            const container = document.getElementById('fireflies-container');
            const count = 8 + Math.floor(Math.random() * 5); // 8-12 fireflies
            
            for (let i = 0; i < count; i++) {
                const fly = document.createElement('div');
                fly.className = 'firefly';
                
                // Random starting position across the viewport
                fly.style.left = `${10 + Math.random() * 80}vw`;
                fly.style.top = `${10 + Math.random() * 80}vh`;
                
                // Randomize movement path
                const r = () => (Math.random() - 0.5) * 100;
                fly.style.setProperty('--fx1', `${r()}px`);
                fly.style.setProperty('--fy1', `${r()}px`);
                fly.style.setProperty('--fx2', `${r()}px`);
                fly.style.setProperty('--fy2', `${r()}px`);
                fly.style.setProperty('--fx3', `${r()}px`);
                fly.style.setProperty('--fy3', `${r()}px`);
                fly.style.setProperty('--fx4', `${r()}px`);
                fly.style.setProperty('--fy4', `${r()}px`);
                
                // Randomize timing
                const duration = 15 + Math.random() * 20;
                fly.style.setProperty('--fly-duration', `${duration}s`);
                fly.style.setProperty('--fly-brightness', `${0.3 + Math.random() * 0.5}`);
                fly.style.animationDelay = `${Math.random() * duration}s`;
                
                container.appendChild(fly);
            }
        }
        
        // Refresh fireflies periodically (they loop, but let's remix positions occasionally)
        function refreshFireflies() {
            const container = document.getElementById('fireflies-container');
            container.innerHTML = '';
            spawnFireflies();
        }

        // === GAME LOOP ===
        function gameLoop() {
            render();
            renderCombineArea();
            renderAchievements();
            spawnWhisper();
        }
        
        // === INIT ===
        calculateOfflineProgress();
        loadState();
        
        // Restore whispers count from state
        if (state.whispersHeard) {
            document.getElementById('whispers-heard').textContent = state.whispersHeard;
        }
        
        render();
        renderCombineArea();
        renderAchievements();
        spawnFireflies();
        setInterval(gameLoop, 500);
        
        // Refresh fireflies every 60 seconds for variety
        setInterval(refreshFireflies, 60000);
        
        // Save periodically
        setInterval(saveState, 5000);
    </script>
</body>
</html>
